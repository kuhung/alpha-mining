# Alpha#29: 复杂价格变换与延迟负收益时序排名的加和

本项目实现了 Alpha#29 因子的计算逻辑。

## 1. Alpha#29 公式

Alpha#29 的计算公式如下：

```
(min(product(rank(rank(scale(log(sum(ts_min(rank(rank((-1 * rank(delta((close - 1), 5))))), 2), 1))))), 1), 5) + ts_rank(delay((-1 * returns), 6), 5))
```

**公式各项说明** (按大致运算顺序解释):

*   `close`: 资产的日收盘价。
*   `returns`: 资产的日收益率。
*   `delta(x, N)`: 计算序列 `x` 当前值与 `N` 天前值的差：`x - x.shift(N)`。
*   `rank(x)`: 对序列 `x` 在截面（特定日期所有资产）上进行百分位排名 (0到1之间)。
*   `ts_min(x, N)`: 计算序列 `x` 在过去 `N` 天窗口内的最小值。
*   `sum(x, N)`: 计算序列 `x` 在过去 `N` 天窗口内的和 (当 `N=1` 时，即取当前值)。
*   `log(x)`: 计算 `x` 的自然对数。实践中需注意处理 `x <= 0` 的情况，例如取 `log(abs(x))` 或对输入进行平滑处理。
*   `scale(x)`: 对序列 `x` 进行横截面标准化处理，使其均值为0，标准差为1。
*   `product(x, N)`: 计算序列 `x` 在过去 `N` 天窗口内的乘积 (当 `N=1` 时，即取当前值)。
*   `min(x, N)`: 计算序列 `x` 在过去 `N` 天窗口内的最小值。
*   `delay(x, N)`: 将序列 `x` 的值向后推移 `N` 天，即取 `N` 天前的值 `x.shift(N)`。
*   `ts_rank(x, N)`: 计算序列 `x` 在过去 `N` 天窗口内的时序百分位排名。

## 2. 核心逻辑

Alpha#29 由两大部分 (`part1` 和 `part2`) 相加而成：

**第一部分: `part1 = min(product(rank(rank(scale(log(sum(ts_min(rank(rank((-1 * rank(delta((close - 1), 5))))), 2), 1))))), 1), 5)`**

1.  `inner_calc = delta(close - 1, 5)`: 计算调整后收盘价 (`close - 1`) 的5日差分。
2.  `ranked1 = rank(inner_calc)`: 对差分进行第一次横截面排名。
3.  `neg_ranked1 = -1 * ranked1`: 将第一次排名结果取负。
4.  `ranked2 = rank(neg_ranked1)`: 对取负后的结果进行第二次横截面排名。
5.  `ranked3 = rank(ranked2)`: 进行第三次横截面排名。
6.  `ts_min_val = ts_min(ranked3, 2)`: 计算第三次排名结果在过去2日窗口内的时序最小值。
7.  `sum_val = sum(ts_min_val, 1)`: 对上述时序最小值进行1日求和（实质上是取当前 `ts_min_val` 的值）。
8.  `log_val = log(sum_val)`: 对 `sum_val` 取自然对数（注意处理定义域问题，如 `sum_val <= 0`）。
9.  `scaled_val = scale(log_val)`: 对对数值进行横截面标准化。
10. `ranked4 = rank(scaled_val)`: 对标准化后的值进行第四次横截面排名。
11. `ranked5 = rank(ranked4)`: 进行第五次横截面排名。
12. `prod_val = product(ranked5, 1)`: 对第五次排名结果进行1日乘积（实质上是取当前 `ranked5` 的值）。
13. `part1 = min(prod_val, 5)`: 计算 `prod_val` 在过去5日窗口内的时序最小值。

**第二部分: `part2 = ts_rank(delay((-1 * returns), 6), 5)`**

1.  `neg_returns = -1 * returns`: 计算负的日收益率。
2.  `delayed_neg_returns = delay(neg_returns, 6)`: 将负收益率序列延迟6天（取6天前的值）。
3.  `part2 = ts_rank(delayed_neg_returns, 5)`: 计算延迟后的负收益率在过去5日窗口内的时序百分位排名。

**最终 Alpha**: `alpha29 = part1 + part2`

## 3. 策略解读

Alpha#29 是一个结构非常复杂、多层嵌套的因子，它试图从价格和收益率序列中提取深层和非线性的信号，可能结合了动量、反转、波动性以及趋势持续性等多种市场微观结构特征。

*   **第一部分 (`part1`) 解读**: 
    *   始于价格的短期变化 (`delta(close - 1, 5)`)。
    *   通过多重排名（`rank`）和取负（`-1 * rank`）操作，可能旨在识别在特定方向上表现极端或持续的资产，并放大这些信号。
    *   `ts_min` 操作关注信号的稳定性或近期低点。
    *   `log` 和 `scale` 变换进一步调整信号的分布和可比性。
    *   最终的 `product` (此处为取值) 和 `min` 操作选取近期（5日内）经过复杂变换后表现最显著（通常是最小）的信号值。
    *   总体而言，`part1` 在捕捉一种经过复杂过滤和强化的价格行为模式，其具体指向（如趋势、反转）较为晦涩，依赖于各操作的综合效果。

*   **第二部分 (`part2`) 解读**: 
    *   关注的是6天前的负收益率 (`delay(-1 * returns, 6)`)。
    *   `ts_rank` 操作衡量了这一延迟负收益率在最近5天内的相对强度（百分位排名）。
    *   这部分带有反转的意味：如果一支股票在6天前有较大的负收益（即 `-1 * returns` 较大），并且这个表现在过去5天中处于较高排名，可能会被视为一个潜在的反弹信号。

*   **组合解读**:
    *   Alpha#29 将这两个高度加工的部分相加。它可能试图找到那些近期价格行为独特（`part1`信号强）**且**在不久前（6天前）经历过显著下跌并且该下跌信号在近期相对突出（`part2`信号强）的股票。
    *   由于公式的极端复杂性和多重非线性变换，其确切的经济学含义和驱动因素难以直观判断，必须通过严格的因子分析和历史回测来验证其有效性和实际预测能力。

## 4. 项目结构

```text
alpha-mining/
├── data/
│   ├── generate_mock_data.py  # 脚本：生成模拟金融数据
│   └── mock_data.csv          # 生成的模拟数据文件
├── alpha/alpha29/
│   ├── alpha_calculator.py    # 脚本：根据公式计算 Alpha#29
│   ├── alpha29_results.csv    # 计算得到的 Alpha#29 结果文件
│   ├── README.md              # 本说明文档
│   └── cast.md                # Alpha#29 策略总结与转换说明
```

## 5. 使用步骤

### 5.1. 环境准备

确保您的 Python 环境中安装了 `pandas` 和 `numpy` 库。

```bash
pip install pandas numpy
```

### 5.2. 数据准备

运行 `alpha_calculator.py` 脚本需要 `mock_data.csv` 文件位于项目根目录下的 `data/` 目录中。该 CSV 文件必须至少包含以下列：

*   `date` (日期)
*   `asset_id` (资产ID)
*   `close` (收盘价)
*   `returns` (收益率)

如果数据文件不存在或需要更新，您可以运行 `data/generate_mock_data.py` (请确保该脚本会生成上述所有必需列)。

### 5.3. 计算 Alpha#29 因子

在 `alpha/alpha29/` 目录下，通过命令行运行 `alpha_calculator.py` 脚本：

```bash
python alpha_calculator.py
```

脚本将：
1.  读取 `../../data/mock_data.csv` 文件。
2.  计算 Alpha#29 因子。
3.  将结果（包括部分原始数据列和计算得到的 `alpha29` 列）保存到当前目录下的 `alpha29_results.csv` 文件中。
4.  在终端打印输出文件的前5行、后5行以及 `alpha29` 列的描述性统计信息。

## 6. Alpha#29 计算示例 (基于实际输出)

### 6.1. 数据快照

根据 `alpha29_results.csv` 的实际输出数据，我们选取 `asset_1` 在 `2025-01-11` 的数据作为示例：

| date       | asset_id | close | returns | alpha29 |
|:-----------|:---------|:------|:--------|:--------|
| 2025-01-11 | asset_1  | 99.5  | -0.0119 | 0.9     |

*(注: `alpha29` 的值直接来自生成的结果文件。空值表示因计算窗口期不足等原因无法计算)*

### 6.2. 计算逻辑简述 (以 asset_1, 2025-01-11 为例)

Alpha#29 的计算涉及大量横截面排名和时序滚动计算，手动回溯单个数据点的完整计算非常复杂。核心在于 `alpha_calculator.py` 中的 Python 代码精确实现了公式的每个嵌套步骤：

*   **对于 `part1`**: 脚本会逐步计算 `delta`, `rank`, `-1*rank`, `rank`, `rank`, `ts_min`, `sum`, `log`, `scale`, `rank`, `rank`, `product`, `min`。
*   **对于 `part2`**: 脚本会计算 `-1*returns`, `delay`, `ts_rank`。
*   最终将 `part1` 和 `part2` 的结果相加，并保留两位小数得到 `alpha29 = 0.9`。

**对 `alpha29 = 0.9` 的解读**: 
在 `2025-01-11` 这一天，`asset_1` 的 `alpha29` 值为 `0.9`。作为一个正值，它表明根据此复杂因子的综合评估，`asset_1` 在该日表现出某种程度的"积极"信号（具体是预测上涨还是其他，需通过因子与未来收益的相关性分析确定）。

## 7. 数据列说明

### 7.1. 输入数据 (`mock_data.csv`)

*   `date`: 交易日期 (例如 `YYYY-MM-DD` 格式)。
*   `asset_id`: 资产的唯一标识符。
*   `close`: 当日收盘价 (数值型) - **核心计算列**。
*   `returns`: 当日回报率 (数值型) - **核心计算列**。
*   *(脚本会保留输入数据中的其他列到输出文件，但它们不直接参与 Alpha#29 的核心计算)*

### 7.2. 输出数据 (`alpha29_results.csv`)

输出的 CSV 文件将包含原始数据中的所有相关列，并附加一列 `alpha29`：

*   `date`, `asset_id`, `close`, `returns` (及其他原始列，如脚本中所包含的)
*   `alpha29`: 计算得到的 Alpha#29 因子值 (浮点数，保留两位小数)。空值（NaN）表示无法计算。

## 8. 注意事项与风险提示

*   **数据窗口期**: 公式中包含如 `delta(..., 5)`, `ts_min(..., 2)`, `min(..., 5)` 以及最长的 `delay(..., 6)` 和 `ts_rank(..., 5)`。因此，第一个有效的 `alpha29` 值至少需要大约6-7个交易日的历史数据才能开始计算（取决于具体函数的 `min_periods` 设置）。根据 `alpha29_results.csv` 示例，第一个非空值出现在 `2025-01-11`。
*   **复杂性与过拟合风险**: Alpha#29 的公式极端复杂，可能导致难以直观解释其经济含义，并增加了在样本内数据上过拟合的风险。
*   **数值稳定性与定义域**: 
    *   `log(x)` 函数要求 `x > 0`。在 `alpha_calculator.py` 实现中，使用了 `np.log(df['part1'].abs().replace(0, 0.0000000001))` 来处理非正数和零的情况，这与原始公式的直接数学含义可能存在细微差异。原始公式中若 `sum_val <= 0`，则 `log` 操作无定义。
    *   多重排名和标准化操作在特定数据分布下也可能引入数值不稳定性或产生极端值。
*   **因子有效性**: Alpha#29 是一个高度复杂的统计因子，不保证其在任何市场条件下都具有预测能力。强烈建议进行严格的回测和跨样本验证。

---

如需帮助或对本文档及代码有任何建议，欢迎随时交流！ 